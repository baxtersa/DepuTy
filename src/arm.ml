(*
* file: arm.mli
* author: Sam Baxter
* date: 1 August 2015
*)

module Operand =
struct
  type register = int

  type operand = 
  | Const8 of int
  | Const16 of int
  | Const32 of int
  | Label of string
  | String of string
  | Register of register
  | Indirect of int option * register

  let registerToString reg = 
    "r" ^ (string_of_int reg)

  let quoteString str =
    "\"" ^ str ^ "\""
  
  let rec toString = function
  | Const8 n -> "#" ^ string_of_int n
  | Const16 n -> "#" ^ string_of_int n
  | Const32 n -> "#" ^ string_of_int n
  | Label str -> str
  | String str -> quoteString str
  | Register r -> "$" ^ (registerToString r)
  | Indirect (offset, r) ->
    (match offset with
    | Some n -> (string_of_int n) ^
      "(" ^ (toString (Register(r))) ^ ")"
    | None -> "(" ^ (toString (Register(r))) ^ ")")

end;;

module Operation =
struct
  open Operand

  type opDouble = operand * operand
  type opTriple = operand * operand * operand

  type operation =
  | Add of opTriple
  | Sub of opTriple
  | Cmp of opDouble
  | Mov of opTriple
  | Ldr of opTriple
  | Str of opTriple

  let toString1Op rator rand =
    rator ^ "\t" ^ (Operand.toString rand)
  let toString2Op rator rand1 rand2 =
    (toString1Op rator rand1) ^ ", " ^ (Operand.toString rand2)
  let toString3Op rator rand1 rand2 rand3 =
    (toString2Op rator rand1 rand2) ^ ", " ^ (Operand.toString rand3)

  let rec toString = function
    | Add (rd, rn, op) -> toString3Op "add" rd rn op
    | Sub (rd, rn, op) -> toString3Op "sub" rd rn op
    | Cmp (rd, rn) -> toString2Op "cmp" rd rn
    | Mov (rd, rn, op) -> toString3Op "mov" rd rn op
    | Ldr (rd, rn, op) -> toString3Op "ldr" rd rn op
    | Str (rd, rn, op) -> toString3Op "str" rd rn op
end;;

module Instruction =
struct
  open Operation

  type instruction = { label : string option;
		       operation : operation }

  let toInstruction lbl opn = { label = lbl; operation = opn }

  let instructionLabel instr = instr.label
  let instructionOperation instr = instr.operation

  let rec toString = function
    | { label = None; operation = opn } -> "\t" ^ (Operation.toString opn)
    | { label = Some lbl; operation = opn} -> lbl ^ ":\t" ^ (Operation.toString opn)
end;;

module Codestream =
struct
  open Instruction

  type codestream = instruction list

  let emit strFilename codestrm =
    let makeFile filename ext =
      let makeFileName filename' ext' =
	let prefix = String.sub filename' 0 (String.rindex filename' '.') in
	prefix ^ "." ^ ext'
      in
      let filename' = makeFileName filename ext in
      let _ = if Sys.file_exists filename'
	then Sys.rename filename' (filename' ^ "~")
	else ()
      in open_out filename'
    in
    let asmOut = makeFile strFilename "asm" in
    let rec writeLoop = function
      | [] -> ()
      | instr::instrs ->
	(
	  output_string asmOut ((Instruction.toString instr) ^ "\n");
	  writeLoop instrs;
	) in
    (
      output_string asmOut ("# Generated by lpic\n#\n");
      writeLoop codestrm;
      close_out asmOut;
    )
end;;
